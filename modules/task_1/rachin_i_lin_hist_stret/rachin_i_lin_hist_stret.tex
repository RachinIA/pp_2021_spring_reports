\documentclass{report}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{amsmath}

\geometry{a4paper,top=2cm,bottom=3cm,left=2cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\lstset{language=C++,
		basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{magenta}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Повышение контраста полутонового изображения посредством линейной растяжки гистограммы»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнил:} \\ студент группы 381808-1 \\ Рачин И. А.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В. \\
}
\vspace{\fill}

\begin{center} Нижний Новгород \\ 2021 \end{center}

\end{titlepage}

\setcounter{page}{2}

% Содержание
\tableofcontents
\newpage

% Введение
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
Одним из простейших методов повышения контрастности является минимаксное растяжение, которое заключается в том, что левый и правый край гистограммы сдвигают к соответствующим границам полного диапазона. Левому краю гистограммы присваивается значение 0, а правому — 255. При этом все промежуточные значения яркости пересчитывают в соответствии с линейной формулой.

\newpage

% Постановка задачи
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
Цель данной лабораторной работы состоит в написании алгоритма линейной растяжки гистограммы с использованием последовательной и двух параллельных схем. Для реализации параллельных схем будут использованы две технологии - OpenMP и TBB. Также будут проведены измерения для того, чтобы сравнить время работы разных вариантов исполнения данного алгоритма.
\newpage

% Описание алгоритма
\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
Линейная растяжка сводится к присваиванию новых значений интенсивности каждому пикселю изображения. Если интенсивности исходного изображения изменялись в диапазоне от $y_{min}$ до $y_{max}$, тогда необходимо линейно "растянуть" указанный диапазон так, чтобы значения изменялись от 0 до 255. Для этого достаточно пересчитать старые значения интенсивности для всех пикселей (x,y) согласно формуле $f^{-1}(y)$ = (y - $y_{min}$) * ${\frac{255}{y_{max} - y_{min}}}$.
\par Весь алгоритм можно кратко представить в виде следующих шагов:
\begin{itemize}
\item Шаг 1: Найти минимум и максимум среди всех значений интенсивности.
\item Шаг 2: Пересчитать старые значения интенсивности для всех пикселей на основе найденных значений используя формулу $f^{-1}(y)$ = (y - $y_{min}$) * ${\frac{255}{y_{max} - y_{min}}}$.

\end{itemize}
\newpage

% Описание схемы распараллеливания
\section*{Описание схемы распараллеливания}
\addcontentsline{toc}{section}{Описание схемы распараллеливания}
Распараллеливание происходит сначала тем, что значения для поиска минимума(min) и максимума(max) разбиваются на несколько частей, в которых находятся локальные min и max. Далее локальные значения сравниваются и заполняются глобальные min и max. Последним шагом является разбиение всех значений на части, и в каждой части параллельно происходит применение ранее упомянутой формулы ко всем локальным значениям.
\newpage

% Описание программной реализации
\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}\
Функция с названием histogramStretching реализует последовательный алгоритм. На вход принимается вектор, состоящий из int значений. На выход передается вектор, состоящий из int значений, к которым была применена формула.
\par Функция с названием histogramStretchingOmp реализует алгоритм с использованием технологии OpenMP. На вход принимается вектор, состоящий из int значений. На выход передается вектор, состоящий из int значений, к которым была применена формула.
\par Функция с названием histogramStretchingTbb реализует алгоритм с использованием технологии OpenMP. На вход принимается вектор, состоящий из int значений. На выход передается вектор, состоящий из int значений, к которым была применена формула.
\newpage

% Результаты экспериментов
\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
Вычисления проводились на компьютере со следующими характеристиками:

\begin{itemize}
\itemПроцессор Intel® Xeon® E5-1650 12 МБ кэш-памяти, 3,20 ГГц, количество ядер: 6, количество потоков: 12
\item Оперативная память: 16 ГБ DDR3;
\end{itemize}

\par Для проведения вычислений использовалось генерируемое изображение в виде вектора элементов типа int и размером 20000 x 20000:
\\

\begin{table}[!h]
\begin{center}
\begin{tabular}{lllllll}
Тип алгоритма & Время \\
SEQ        & 1.174 \\
OMP        & 0.894 \\
TBB        &  0.754 \\

\end{tabular}
\end{center}
\caption{Результаты вычислительных экспериментов}
\centering
\end{table}

\par По данным результатам можно сделать вывод что параллельная реализация выполняется заметно быстрее. В частности исполнение при помощи технологии TBB является более быстрым, чем исполнение OpenMP.
\newpage

% Заключение
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В ходе данной лабораторной работы были написаны алгоритмы линейной растяжки гистограммы с использованием последовательной и двух параллельных схем. Для реализации параллельных схем были использованы две технологии - OpenMP и TBB. Также были проведены измерения, которые показали, что самым быстрым оказался алгоритм, использующий TBB технологию для распараллеливания.
\newpage

% Литература
\begin{thebibliography}{1}
\addcontentsline{toc}{section}{Литература}
\bibitem{Gorodetsky} Турлапов В. Е. «Обработка изображений. Часть 1».
\\URL:\url {http://www.graph.unn.ru/rus/materials/CG/CG03_ImageProcessing.pdf} (дата обращения: 22.05.2021)
\bibitem{} «Параллельное программирование на OpenMP»
\\URL:\url {http://ccfit.nsu.ru/arom/data/openmp.pdf} (дата обращения: 22.05.2021)
\bibitem{Sidnev} Сиднев А.А., Мееров И.Б., Сысоев А.В. «Разработка параллельных программ в системах с общей памятью с использованием библиотеки Intel Threading Building Blocks (TBB)».
\\URL:\url {http://hpc-education.ru/files/lectures/meerov/ppt06.pdf} (дата обращения: 22.05.2021)
\newpage

% Приложение
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
\begin{lstlisting}
(lin_hist_stret.cpp)
// Copyright 2021 Rachin Igor
#include "../../modules/task_2/rachin_i_lin_hist_stret_omp/lin_hist_stret.h"
#include <random>
#include <vector>
#include <ctime>
std::vector<int> getRandomMatrix(int rows, int clmns) {
    if (rows <= 0 || clmns <= 0) {
        return std::vector<int>();
    }
    int sizeM = rows * clmns;
    std::mt19937 gen;
    gen.seed(static_cast<unsigned int>(time(0)));
    std::vector<int> mx(sizeM);
    for (int i = 0; i < sizeM; i++) {
            mx[i] = gen() % 256;
    }
    return mx;
}

std::vector<int> histogramStretching(const std::vector<int>& mx, int rows, int clmns) {
    std::vector<int> empty;
    if (rows <= 0 || clmns <= 0 || mx == empty) {
        return std::vector<int>();
    }
    int sizeM = rows * clmns;
    int maxIntensity = mx[0];
    int minIntensity = mx[0];
    std::vector<int> stretchedMatrix(sizeM);
    for (int i = 1; i < sizeM; i++) {
        if (mx[i] > maxIntensity) {
            maxIntensity = mx[i];
            continue;
        }
        if (mx[i] < minIntensity) {
            minIntensity = mx[i];
        }
    }
    for (int i = 0; i < sizeM; i++) {  // Formul of linear histogram stretching
        stretchedMatrix[i] = (mx[i] - minIntensity) * (255 / (maxIntensity - minIntensity));
    }
    return stretchedMatrix;
}

std::vector<int> histogramStretchingOmp(const std::vector<int>& mx, int rows, int clmns) {
    std::vector<int> empty;
    if (rows <= 0 || clmns <= 0 || mx == empty) {
        return std::vector<int>();
    }
    int sizeM = rows * clmns;
    int maxIntensity = mx[0];
    int minIntensity = mx[0];
    std::vector<int> stretchedMatrix(sizeM);
#pragma omp parallel
    {
        int localMin = minIntensity;
        int localMax = maxIntensity;
#pragma omp for
        for (int i = 1; i < sizeM; i++) {
            if (mx[i] > localMax) {
                localMax = mx[i];
                continue;
            }
            if (mx[i] < localMin) {
                localMin = mx[i];
            }
        }
#pragma omp critical
        {
            if (localMax > maxIntensity) {
                maxIntensity = localMax;
            }
            if (localMin < minIntensity) {
                minIntensity = localMin;
            }
        }
#pragma omp barrier
#pragma omp for
        for (int i = 0; i < sizeM; i++) {  // Formul of linear histogram stretching
            stretchedMatrix[i] = (mx[i] - minIntensity) * (255 / (maxIntensity - minIntensity));
        }
    }
    return stretchedMatrix;
}


\end{lstlisting}
\newpage
\begin{lstlisting}
(lin_hist_stret.cpp)
// Copyright 2021 Rachin Igor
#ifndef MODULES_TASK_2_RACHIN_I_LIN_HIST_STRET_OMP_LIN_HIST_STRET_H_
#define MODULES_TASK_2_RACHIN_I_LIN_HIST_STRET_OMP_LIN_HIST_STRET_H_

#include <vector>

std::vector<int> getRandomMatrix(int rows, int clmns);
std::vector<int> histogramStretching(const std::vector<int>& mx, int rows, int clmns);
std::vector<int> histogramStretchingOmp(const std::vector<int>& mx, int rows, int clmns);

#endif  // MODULES_TASK_2_RACHIN_I_LIN_HIST_STRET_OMP_LIN_HIST_STRET_H_


\end{lstlisting}
\newpage
\begin{lstlisting}
(main.cpp реализация у TBB)
// Copyright 2018 Nesterov Alexander
#include <gtest/gtest.h>
#include <vector>
#include <tbb/tick_count.h>

#include "./lin_hist_stret.h"

TEST(Parallel_Operations_TBB, Test_random_matrix_with_negative_size) {
    std::vector<int> empty;  // empty vector
    int size = -5;
    ASSERT_EQ(getRandomMatrix(size, size), empty);
}

TEST(Parallel_Operations_TBB, Test_negative_size_stretching) {
    std::vector<int> empty;  // empty vector
    std::vector<int> test;
    int size = -5;
    ASSERT_EQ(histogramStretching(test, size, size), empty);
}

TEST(Parallel_Operations_TBB, Test_values_range_of_random_matrix) {
    int size = 4;
    int rightRange = 1;
    std::vector<int> test = getRandomMatrix(size, size);
    for (int i = 0; i < size * size; i++) {
        if (test[i] < 0 || test[i]>255) {
            rightRange = 0;
        }
    }
    ASSERT_EQ(rightRange, 1);
}

TEST(Parallel_Operations_TBB, Test_stretching_of_manual_matrix) {
    int size = 3;
    std::vector<int> test{ 100, 245, 100,
                           45, 245, 45,
                           100, 245, 100 };
    std::vector<int> result{ 55, 200, 55,
                             0, 200, 0,
                             55, 200, 55 };
    ASSERT_EQ(histogramStretching(test, size, size), result);
}

TEST(Parallel_Operations_TBB, Test_stretching_of_random_matrix) {
    int size = 1000;
    std::vector<int> test = getRandomMatrix(size, size);
    std::vector<int> empty;  // empty vector
    test = histogramStretching(test, size, size);
    ASSERT_NE(test, empty);
}

TEST(Parallel_Operations_TBB, Test_negative_size_tbb_stretching) {
    std::vector<int> empty;  // empty vector
    std::vector<int> test;
    int size = -5;
    ASSERT_EQ(histogramStretchingTbb(test, size, size), empty);
}

TEST(Parallel_Operations_TBB, Comparison_seq_with_tbb) {
    int size = 20000;
    std::vector<int> mx = getRandomMatrix(size, size);
    std::vector<int> seq;
    std::vector<int> tbb;
    tbb::tick_count startSeq = tbb::tick_count::now();
    seq = histogramStretching(mx, size, size);
    tbb::tick_count endSeq = tbb::tick_count::now();
    tbb::tick_count startTbb = tbb::tick_count::now();
    tbb = histogramStretchingTbb(mx, size, size);
    tbb::tick_count endTbb = tbb::tick_count::now();
    printf("Sequential: %f seconds\n", (endSeq - startSeq).seconds());
    printf("Tbb:        %f seconds\n", (endTbb - startTbb).seconds());
    ASSERT_EQ(seq, tbb);
}

TEST(Parallel_Operations_TBB, Comparison_hists) {
    int size = 5000;
    std::vector<int> mx = getRandomMatrix(size, size);
    std::vector<int> seq;
    std::vector<int> tbb;
    seq = histogramStretching(mx, size, size);
    tbb = histogramStretchingTbb(mx, size, size);
    std::vector<int> seq_hist(256, 0);
    std::vector<int> tbb_hist(256, 0);
    for (int i = 1; i < size*size; i++) {
        seq_hist[seq[i]]++;
        tbb_hist[tbb[i]]++;
    }

    ASSERT_EQ(seq_hist, tbb_hist);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

\end{lstlisting}
\newpage
\begin{lstlisting}
(lin_hist_stret.cpp)
// Copyright 2021 Rachin Igor
#include <tbb/tbb.h>
#include <vector>
#include <string>
#include <random>
#include <functional>
#include <numeric>
#include <ctime>
#include "../../modules/task_3/rachin_i_lin_hist_stret_tbb/lin_hist_stret.h"
std::vector<int> getRandomMatrix(int rows, int clmns) {
    if (rows <= 0 || clmns <= 0) {
        return std::vector<int>();
    }
    int sizeM = rows * clmns;
    std::mt19937 gen;
    gen.seed(static_cast<unsigned int>(time(0)));
    std::vector<int> mx(sizeM);
    for (int i = 0; i < sizeM; i++) {
            mx[i] = gen() % 256;
    }
    return mx;
}

std::vector<int> histogramStretching(const std::vector<int>& mx, int rows, int clmns) {
    std::vector<int> empty;
    if (rows <= 0 || clmns <= 0 || mx == empty) {
        return std::vector<int>();
    }
    int sizeM = rows * clmns;
    int maxIntensity = mx[0];
    int minIntensity = mx[0];
    std::vector<int> stretchedMatrix(sizeM);
    for (int i = 1; i < sizeM; i++) {
        if (mx[i] > maxIntensity) {
            maxIntensity = mx[i];
            continue;
        }
        if (mx[i] < minIntensity) {
            minIntensity = mx[i];
        }
    }
    for (int i = 0; i < sizeM; i++) {  // Formul of linear histogram stretching
        stretchedMatrix[i] = (mx[i] - minIntensity) * (255 / (maxIntensity - minIntensity));
    }
    return stretchedMatrix;
}

std::vector<int> histogramStretchingTbb(const std::vector<int>& mx, int rows, int clmns) {
    std::vector<int> empty;
    if (rows <= 0 || clmns <= 0 || mx == empty) {
        return std::vector<int>();
    }
    int sizeM = rows * clmns;
    int maxIntensity = mx[0];
    int minIntensity = mx[0];

    std::vector<int> stretchedMatrix(sizeM);

    tbb::parallel_for(0, static_cast<int>(mx.size()), [&](const int i) {
        if (mx[i] > maxIntensity) {
            maxIntensity = mx[i];
        }
        if (mx[i] < minIntensity) {
            minIntensity = mx[i];
        }
    });

    tbb::parallel_for(0, static_cast<int>(mx.size()), [&](const int i) {
        stretchedMatrix[i] = ((mx[i] - minIntensity) * 255) / (maxIntensity - minIntensity);
        });

    return stretchedMatrix;
}

\end{lstlisting}
\newpage
\begin{lstlisting}
(lin_hist_stret.h)
// Copyright 2021 Rachin Igor
#ifndef MODULES_TASK_3_RACHIN_I_LIN_HIST_STRET_TBB_LIN_HIST_STRET_H_
#define MODULES_TASK_3_RACHIN_I_LIN_HIST_STRET_TBB_LIN_HIST_STRET_H_

#include <vector>

std::vector<int> getRandomMatrix(int rows, int clmns);
std::vector<int> histogramStretching(const std::vector<int>& mx, int rows, int clmns);
std::vector<int> histogramStretchingTbb(const std::vector<int>& mx, int rows, int clmns);

#endif  // MODULES_TASK_3_RACHIN_I_LIN_HIST_STRET_TBB_LIN_HIST_STRET_H_

\end{lstlisting}
\end{document}